"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TestHelper_1 = require("./TestHelper");
var FAILURE_STRING = 'The cohesion of this class is too low. Consider splitting this class into multiple cohesive classes: ';
describe('minClassCohesionRule', function () {
    var ruleName = 'min-class-cohesion';
    it('should pass on empty class', function () {
        var script = "\n            class EmptyClass {\n            }\n        ";
        TestHelper_1.TestHelper.assertViolations(ruleName, script, []);
    });
    it('should pass on class with instance fields and no instance methods', function () {
        var script = "\n            // classes with instance fields\n            class ClassWithField {\n                private field;\n            }\n        ";
        TestHelper_1.TestHelper.assertViolations(ruleName, script, []);
    });
    it('should pass on class with constructor parameters creating instance fields and no instance methods', function () {
        var script = "\n            // classes with instance fields\n            class ClassWithField {\n                constructor(private field) {\n                }\n            }\n        ";
        TestHelper_1.TestHelper.assertViolations(ruleName, script, []);
    });
    it('should fail on class without instance fields', function () {
        var script = "\n            // classes without instance fields\n            class ClassWithoutFields {\n                private someMethod() {\n                }\n            }\n        ";
        TestHelper_1.TestHelper.assertViolations(ruleName, script, [
            {
                failure: FAILURE_STRING + 'ClassWithoutFields',
                name: 'file.ts',
                ruleName: 'min-class-cohesion',
                startPosition: { character: 13, line: 3 },
            },
        ]);
    });
    it('should pass on class with constructor parameters, instance fields, and instance method using all fields', function () {
        var script = "\n            class CohesiveClass {\n                constructor(private a: number) {\n                }\n                public b: number;\n                public sum(): number {\n                    return this.a + this.b;\n                }\n            }\n        ";
        TestHelper_1.TestHelper.assertViolations(ruleName, script, []);
    });
    it('should pass on class with constructor parameters, instance fields, and instance method using all fields', function () {
        var script = "\n            class HalfCohesiveClass {\n                constructor(private a: number) {\n                }\n                public b: number;\n                public getA(): number {\n                    return this.a;\n                }\n                public getB(): number {\n                    return this.b;\n                }\n            }\n        ";
        TestHelper_1.TestHelper.assertViolations(ruleName, script, []);
    });
    it('should fail on class with constructor parameters, instance fields, and instance method using all fields', function () {
        var script = "\n            class ThirdCohesiveClass {\n                constructor(private a: number) {\n                }\n                public b: number;\n                private c: number;\n                public getA(): number {\n                    return this.a;\n                }\n                public getB(): number {\n                    return this.b;\n                }\n                public getC(): number {\n                    return this.c;\n                }\n            }\n        ";
        TestHelper_1.TestHelper.assertViolations(ruleName, script, [
            {
                failure: FAILURE_STRING + 'ThirdCohesiveClass',
                name: 'file.ts',
                ruleName: 'min-class-cohesion',
                startPosition: { character: 13, line: 2 },
            },
        ]);
    });
    it('should pass on Stack class', function () {
        var script = "\n            class Stack {\n                private topOfStack: number = 0;\n                private elements: number[] = [];\n                public size(): number {\n                    return this.topOfStack;\n                }\n                public push(element: number): void {\n                    this.topOfStack++;\n                    this.elements.push(element);\n                }\n                public pop(): number {\n                    if (this.topOfStack === 0)\n                        throw new Error(\"PoppedWhenEmpty\");\n                    const element: number = this.elements[--this.topOfStack];\n                    this.elements = this.elements.slice(this.topOfStack, 1);\n                    return element;\n                }\n            }\n        ";
        TestHelper_1.TestHelper.assertViolations(ruleName, script, []);
    });
    it('should pass on SubClass class', function () {
        var script = "\n            class BaseClass {\n                private field1: number = 2;\n            }\n            class SubClass extends BaseClass {\n                private field2: number = 2;\n                private subFunction() {\n                    return this.field1 + this.field2;\n                }\n            }\n        ";
        TestHelper_1.TestHelper.assertViolations(ruleName, script, []);
    });
    it('should pass on SubClass class not using instance fields', function () {
        var script = "\n            class BaseClass {\n                private field1: number = 2;\n            }\n            class SubClass extends BaseClass {\n                private field2: number = 2;\n                private subFunction() {\n                    return this.field1;\n                }\n            }\n        ";
        TestHelper_1.TestHelper.assertViolations(ruleName, script, []);
    });
    it('should pass on class with cohesive getters', function () {
        var script = "\n            class CohesiveClass {\n                constructor(private a: number) {\n                }\n                public b: number;\n                public get sum(): number {\n                    return this.a + this.b;\n                }\n            }\n        ";
        TestHelper_1.TestHelper.assertViolations(ruleName, script, []);
    });
    it('should pass on class with uncohesive static methods', function () {
        var script = "\n            class CohesiveClass {\n                constructor(private a: number) {\n                }\n                public b: number;\n                public get sum(): number {\n                    return this.a + this.b;\n                }\n                public static bad1(): number {\n                    return 1;\n                }\n                public static bad2(): number {\n                    return 2;\n                }\n                public static bad3(): number {\n                    return 3;\n                }\n            }\n        ";
        TestHelper_1.TestHelper.assertViolations(ruleName, script, []);
    });
    context('reading options', function () {
        context('90% cohesion', function () {
            var options;
            beforeEach(function () {
                options = [true, 0.9];
            });
            it('should fail on Stack class', function () {
                var script = "\n                class Stack {\n                    private topOfStack: number = 0;\n                    private elements: number[] = [];\n                    public size(): number {\n                        return this.topOfStack;\n                    }\n                    public push(element: number): void {\n                        this.topOfStack++;\n                        this.elements.push(element);\n                    }\n                    public pop(): number {\n                        if (this.topOfStack === 0)\n                            throw new Error(\"PoppedWhenEmpty\");\n                        const element: number = this.elements[--this.topOfStack];\n                        this.elements = this.elements.slice(this.topOfStack, 1);\n                        return element;\n                    }\n                }\n                ";
                TestHelper_1.TestHelper.assertViolationsWithOptions(ruleName, options, script, [
                    {
                        failure: FAILURE_STRING + 'Stack',
                        name: 'file.ts',
                        ruleName: 'min-class-cohesion',
                        startPosition: { character: 17, line: 2 },
                    },
                ]);
            });
        });
        context('80% cohesion', function () {
            var options;
            beforeEach(function () {
                options = [true, 0.8];
            });
            it('should pass on Stack class', function () {
                var script = "\n                            class Stack {\n                                private topOfStack: number = 0;\n                                private elements: number[] = [];\n                                public size(): number {\n                                    return this.topOfStack;\n                                }\n                                public push(element: number): void {\n                                    this.topOfStack++;\n                                    this.elements.push(element);\n                                }\n                                public pop(): number {\n                                    if (this.topOfStack === 0)\n                                        throw new Error(\"PoppedWhenEmpty\");\n                                    const element: number = this.elements[--this.topOfStack];\n                                    this.elements = this.elements.slice(this.topOfStack, 1);\n                                    return element;\n                                }\n                            }\n                            ";
                TestHelper_1.TestHelper.assertViolationsWithOptions(ruleName, options, script, []);
            });
        });
    });
});
//# sourceMappingURL=MinClassCohesionRuleTests.js.map